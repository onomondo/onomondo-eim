% Author: Philipp Maier <pmaier@sysmocom.de> / sysmocom - s.f.m.c. GmbH

%TODO: This code still lacks the verification of signatures, the reason for this is that it was still not possible to
%verify a signature in practice.

-module(crypto_utils).

-export([sign_euiccPackageSigned/2,
	 verify_euiccPackageResultSigned/3,
	 store_euicc_pubkey_from_authenticateResponseOk/2,
	 store_euicc_pubkey_from_ipaEuiccDataResponse/2]).

%temporary, for debugging
-export([der_to_plain/1, plain_to_der/1, verify_experiment1/0, verify_experiment2/0]).

%Convert from DER encoded signature format to plain format (see also BSI TR03111 5.2.1)
der_to_plain(DERSignature) ->
    {ok, [R, S]} = 'DERSignature':decode('DERSignature', DERSignature),
    RPlain = utils:lpad_binary(utils:integer_to_bytes(R), <<0>>, 32),
    SPlain = utils:lpad_binary(utils:integer_to_bytes(S), <<0>>, 32),
    utils:join_binary_list([RPlain, SPlain]).

%Convert from plain format to DER encoded signature format (see also BSI TR03111 5.2.1)
plain_to_der(PlainSignature) ->
    R = binary_part(PlainSignature, 0, 32),
    S = binary_part(PlainSignature, 32, 32),
    DERSignature = [binary:decode_unsigned(R),binary:decode_unsigned(S)],
    {ok, DERSignatureEncoded} = 'DERSignature':encode('DERSignature', DERSignature),
    DERSignatureEncoded.

sign_euiccPackageSigned(EuiccPackageSigned, EidValue) ->
    % Read the AssociationToken
    {ok, AssociationToken} = mnesia_db:euicc_param_get(EidValue, associationToken),
    AssociationTokenBinary = utils:integer_to_bytes(AssociationToken),
    AssociationTokenLength = utils:integer_to_bytes(byte_size(AssociationTokenBinary)),
    AssociationTokenBer =  utils:join_binary_list([<<132>>, AssociationTokenLength, AssociationTokenBinary]),

    %Format message to be signed
    {ok, EuiccPackageSignedEnc} = 'SGP32Definitions':encode('EuiccPackageSigned', EuiccPackageSigned),
    MsgToBeSigned = utils:join_binary_list([EuiccPackageSignedEnc, AssociationTokenBer]),

    %Load private key from eIM certificate
    {ok, EimKeyPath} = application:get_env(onomondo_eim, eim_key),
    {ok, EimKeyPem} = file:read_file(EimKeyPath),
    [EimKeyPemEntry] = public_key:pem_decode(EimKeyPem),
    EimKeyECPrivateKey = public_key:pem_entry_decode(EimKeyPemEntry),

    %Sign message
    % We use SHA-256 as signature hash/digest, see also GSMA SGP.22, section 2.6.5 and
    % https://www.erlang.org/doc/apps/public_key/public_key#sign/4
    der_to_plain(public_key:sign(MsgToBeSigned, sha256, EimKeyECPrivateKey)).

verify_signature(Message, Signature, EidValue) ->
    DERSignature = plain_to_der(Signature),

    {ok, SubjectPublicKeyHex} = mnesia_db:euicc_param_get(EidValue, signPubKey),
    SubjectPublicKey = utils:hex_to_binary(SubjectPublicKeyHex),

    {ok, SignAlgo} = mnesia_db:euicc_param_get(EidValue, signAlgo),
    NamedCurve = case SignAlgo of
		     <<"prime256v1">> ->
			 {1,2,840,10045,3,1,7};
		     <<"brainpoolP256r1">> ->
			 {1,3,36,3,3,2,8,1,1,7};
		     _ ->
			 logger:error("invalid SignAlgo configured for eID: ~p~n", [utils:binary_to_hex(EidValue)]),
			 {}
		 end,

    ECPublicKey = {{'ECPoint',SubjectPublicKey}, {namedCurve, NamedCurve}},

    Result = public_key:verify(Message, sha256, DERSignature, ECPublicKey),
    case Result of
	true ->
	    ok;
	_ ->
	    logger:error("Signature verification failed for eID ~p, input parameters:~n" ++
			     "SubjectPublicKey=~p~n" ++
			     "NamedCurve=~p~n" ++
			     "Signature=~p~n" ++
			     "DERSignature=~p~n" ++
			     "Message=~p~n", [utils:binary_to_hex(EidValue),
					      utils:binary_to_hex(SubjectPublicKey),
					      NamedCurve,
					      utils:binary_to_hex(Signature),
					      utils:binary_to_hex(DERSignature),
					      utils:binary_to_hex(Message)]),
	    error
    end.

% An experiment to prove that the overall signature verification works, expected return ok, The hex data in this
% function was generated by triggering a download from the eUICC (EID=89044045118427484800000000011628) and capturing
% euiccSigned1 and euiccSignature1.
verify_experiment1() ->
    EuiccSigned1Hex = <<"3082011e8010aee5074869da4d8fa478124916ad54ed831974657374736d6470706c7573312e6578616d706c652e636f6d8410f6581fc7a6b99c28866b0ffcc41a31c9bf2281ac810302030182030205008303240215840d810100820400049ce8830222238505006b36d3c3860311020087030203008802029ca92c0414f54172bdf98a95d65cbeb88a38a1c11d800a85c30414c0bc70ba36929d43b467ff57570530e57ab8fcd8aa2c0414f54172bdf98a95d65cbeb88a38a1c11d800a85c30414c0bc70ba36929d43b467ff57570530e57ab8fcd804030100000c0f5359534d4f434f4d2d544553542d31af050403030301a02d80215453343856312d422d554e495155452d6e6f6a617661636172642d6e6f6373696da108800412345678a100">>,
    EuiccSignature1Hex = <<"5f9b24ba9e1b7c8647c22679e1f674d93c79b9c0ae05005c835b95664678b1351a9e1b59849da764acc6f70ae0061a85a8d73f063a78157405beac5e56aad2ec">>,
    verify_signature(utils:hex_to_binary(EuiccSigned1Hex), utils:hex_to_binary(EuiccSignature1Hex), <<89044045118427484800000000011628>>).

% An experiment to prove that the verfication of signatures also works in the context of eUICC packages. Unfortunately
% the spec is very vague about how the input data should be prepared. As of now none of the attempts here do work.
% However since verify_experiment1 works, we can conclude that the key and crypto is correct and it must be the input
% data that is wrong.
verify_experiment2() ->
% The following data was captured from an eUICC package sent to a test eUICC (EID=89044045118427484800000000011628):

% Data captured on the IPAd side
%TX:
%BF4F8186BF518182303D800365494D5A1089044045118427484800000000011628810203EE8210F92B2FEE35632499E841CB754FDFD9F3A00EA30C5A0A989444999999990920F35F37408D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223
%TX(eUICC):
%BF518182303D800365494D5A1089044045118427484800000000011628810203EE8210F92B2FEE35632499E841CB754FDFD9F3A00EA30C5A0A989444999999990920F35F37408D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223
%RX:
%BF5081E23081DFBF516AA0683023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F383011430038301015F37409EB61D189D332FF2DC6FF90A97A9438AB973F04E6FE2F106FA9C7809A36B8A12740E113C583009D3859A3B2EABE6F43409AE46F32CFD34E2D023B2561F9F2311BF2B6FA26DBF516AA0683023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F383011430038301015F37400523BFA5A4F0CAAA1D42637520E2DEF2DDC96FBE775342BB13D3D6EB6AD919951354FB59082675038D949131ECF3AF272F771A085E3C2099DC45C897E9808022
%RX(eUICC):
%BF516AA0683023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F383011430038301015F37409EB61D189D332FF2DC6FF90A97A9438AB973F04E6FE2F106FA9C7809A36B8A12740E113C583009D3859A3B2EABE6F43409AE46F32CFD34E2D023B2561F9F2311

% Data captured on the eIM side:
%============EuiccPackageResultDataSigned_enc><<"3023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F38301143003830101">>
%============EimSignature><<"8D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223">>
%============EuiccSignEPR><<"9EB61D189D332FF2DC6FF90A97A9438AB973F04E6FE2F106FA9C7809A36B8A12740E113C583009D3859A3B2EABE6F43409AE46F32CFD34E2D023B2561F9F2311">>

    EuiccSignEPRHex = <<"9EB61D189D332FF2DC6FF90A97A9438AB973F04E6FE2F106FA9C7809A36B8A12740E113C583009D3859A3B2EABE6F43409AE46F32CFD34E2D023B2561F9F2311">>,

%Data objects without tags
    EuiccPackageResultDataSignedHex = <<"3023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F38301143003830101">>,
    EimSignatureHex = <<"8D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223">>,

%Both Data objects with tags
%    EuiccPackageResultDataSignedHex = <<"A0683023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F38301143003830101">>,
%    EimSignatureHex = <<"5F37408D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223">>,

%Only signature data object with tags
%    EuiccPackageResultDataSignedHex = <<"3023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F38301143003830101">>,
%    EimSignatureHex = <<"5F37408D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223">>,

%Only signature data object with tags and the whole eUICC message (without its signature)
%    EuiccPackageResultDataSignedHex = <<"BF516AA0683023800365494D810203EE8210F92B2FEE35632499E841CB754FDFD9F38301143003830101">>,
%    EimSignatureHex = <<"5F37408D5DE179B03A3FE13CD3A7E5A947FDDBB831ACC8F9AAFDC9777D314837CB0C805EE3029BF2445611C1580DC4470147DD6293ECA66987BC9A0A704CAB0031B223">>,

    MessageHex = <<EuiccPackageResultDataSignedHex/binary, EimSignatureHex/binary>>,
    verify_signature(utils:hex_to_binary(MessageHex), utils:hex_to_binary(EuiccSignEPRHex), <<89044045118427484800000000011628>>).

verify_euiccPackageResultSigned(EuiccPackageResult, EimSignature, EidValue) ->
    {ok, ConsumerEuicc} = mnesia_db:euicc_param_get(EidValue, consumerEuicc),
    case ConsumerEuicc of
	false ->
	    case EuiccPackageResult of
		{euiccPackageResultSigned, EuiccPackageResultSigned} ->
		    EuiccPackageResultDataSigned = maps:get(euiccPackageResultDataSigned, EuiccPackageResultSigned),
		    EuiccSignEPR = maps:get(euiccSignEPR, EuiccPackageResultSigned),
		    {ok, EuiccPackageResultDataSigned_enc} = 'SGP32Definitions':encode('EuiccPackageResultDataSigned',
										       EuiccPackageResultDataSigned),
		    % "euiccSignEPR SHALL apply on the concatenated data objects euiccPackageResultDataSigned and
		    % eimSignature." (see also GSMA SGP.32, section 2.11.2.1)
		    MsgToBeVerfied = utils:join_binary_list([EuiccPackageResultDataSigned_enc, EimSignature]),
		    verify_signature(MsgToBeVerfied, EuiccSignEPR, EidValue);
		{euiccPackageErrorSigned, EuiccPackageErrorSigned} ->
		    EuiccPackageErrorDataSigned = maps:get(euiccPackageErrorDataSigned, EuiccPackageErrorSigned),
		    EuiccSignEPE = maps:get(euiccSignEPR, EuiccPackageErrorSigned),
		    {ok, EuiccPackageErrorDataSigned_enc} = 'SGP32Definitions':encode('EuiccPackageErrorDataSigned',
										      EuiccPackageErrorDataSigned),
		    % "euiccSignEPE SHALL apply on the concatenated data objects euiccPackageErrorDataSigned and
		    % eimSignature." (see also GSMA SGP.32, section 2.11.2.1)
		    MsgToBeVerfied = utils:join_binary_list([EuiccPackageErrorDataSigned_enc, EimSignature]),
		    verify_signature(MsgToBeVerfied, EuiccSignEPE, EidValue);
		{euiccPackageErrorUnsigned, _} ->
		    ok; % This result has no signature
		_ ->
		    error
	    end;
	_ ->
	    logger:info("omitting signature check for euiccPackageResultSigned from eID ~p (consumer eUICC)~n",
			[utils:binary_to_hex(EidValue)]),
	    ok
    end.

pubkey_from_cert(Cert) ->
    TbsCertificate = maps:get(tbsCertificate, Cert),
    SubjectPublicKeyInfo = maps:get(subjectPublicKeyInfo, TbsCertificate),
    Algorithm = maps:get(algorithm, SubjectPublicKeyInfo),
    SubjectPublicKey = maps:get(subjectPublicKey, SubjectPublicKeyInfo),
    BrainpoolP256r1 = #{algorithm => {1,2,840,10045,2,1},
                        parameters => <<6,9,43,36,3,3,2,8,1,1,7>>},
    Prime256v1 = #{algorithm => {1,2,840,10045,2,1},
		   parameters => <<6,8,42,134,72,206,61,3,1,7>>},
    NamedCurve = case Algorithm of
		     Prime256v1 ->
			 {1,2,840,10045,3,1,7};
		     BrainpoolP256r1 ->
			 {1,3,36,3,3,2,8,1,1,7};
		     _ ->
			 throw("Incorrect root CI certificate, only BrainpoolP256r1 or Prime256v1 may be used!")
		 end,
    {{'ECPoint', SubjectPublicKey}, {namedCurve, NamedCurve}}.

verify_cert(TrustedCert, VerifyCert) ->
    {ok, VerifyCertBer} = 'PKIX1Explicit88':encode('Certificate', VerifyCert),
    ECPublicKey = pubkey_from_cert(TrustedCert),
    Result = public_key:pkix_verify(VerifyCertBer, ECPublicKey),
    case Result of
	true ->
	    ok;
	_ ->
	    logger:error("Certificate verification failed,~nVerifyCert=~p,~nECPublicKey=~p~n", [VerifyCert, ECPublicKey]),
	    error
    end.

verify_euicc_cert(EumCertificate, EuiccCertificate) ->
    {ok, RootCiCertPath} = application:get_env(onomondo_eim, root_ci_cert),
    {ok, RootCiCertPem} = file:read_file(RootCiCertPath),
    [{'Certificate', RootCiCertBer, not_encrypted}] = public_key:pem_decode(RootCiCertPem),
    {ok, RootCiCert} = 'PKIX1Explicit88':decode('Certificate', RootCiCertBer),

    % TODO: The certificate chain validation done here only performs a basic signature validation. However, a
    % spec compliant certifiate chain verification should include:
    %
    % * expiration dates: no certificate in the chain must be expired.
    % * CRL (certificate revocation lists, indicated in the CI cert): no revoked cert should be accepted.
    % * serial number constraint of EUM certificate: first 8 digits of EID of eUICC certificate must be within
    %   scope of EUM certificate.
    % * CA certificate must
    %   - have extension for basic constraints CA=true
    %   - have extension for key usage "keyCertSign"
    % * EUM certificate must
    %   - have extension for basic constraints CA=true, pathLenConstraint == 0
    %   - have extension for key usage "keyCertSign"
    % * eUICC certificate must
    %   - have extension for key usage "digitalSignature"

    case verify_cert(RootCiCert, EumCertificate) of
	ok ->
	    case verify_cert(EumCertificate, EuiccCertificate) of
		ok ->
		    ok;
		_ ->
		    error
	    end;
	_ ->
	    error
    end.

store_euicc_pubkey(EumCertificate, EuiccCertificate, EidValue) ->
    case verify_euicc_cert(EumCertificate, EuiccCertificate) of
	ok ->
	    {{'ECPoint', SignPubKey}, {namedCurve, NamedCurve}} = pubkey_from_cert(EuiccCertificate),
	    SignAlgo = case NamedCurve of
			   {1,2,840,10045,3,1,7} ->
			       <<"prime256v1">>;
			   {1,3,36,3,3,2,8,1,1,7} ->
			       <<"brainpoolP256r1">>;
			   _ ->
			       <<"unknown">>
		       end,
	    ok = mnesia_db:euicc_param_set(EidValue, signPubKey, utils:binary_to_hex(SignPubKey)),
	    ok = mnesia_db:euicc_param_set(EidValue, signAlgo, SignAlgo),
	    ok;
	_ ->
	    error
    end.

store_euicc_pubkey_from_authenticateResponseOk(AuthRespOk, EidValue) ->
    case mnesia_db:euicc_param_get(EidValue, signPubKey) of
	{ok, <<>>} ->
	    % There is no public key stored yet for this eUICC, use the public
	    % key provided in the eUICC certificate
	    EumCertificate =  maps:get(eumCertificate, AuthRespOk),
	    EuiccCertificate = maps:get(euiccCertificate, AuthRespOk),
	    store_euicc_pubkey(EumCertificate, EuiccCertificate, EidValue);
	_ ->
	    % There is already a public key stored for this eUICC
	    ok
    end.

store_euicc_pubkey_from_ipaEuiccDataResponse(IpaEuiccDataResponse, EidValue) ->
    case mnesia_db:euicc_param_get(EidValue, signPubKey) of
	{ok, <<>>} ->
	    % There is no public key stored yet for this eUICC, use the public
	    % key provided in the eUICC certificate
	    case IpaEuiccDataResponse of
		{ipaEuiccData, IpaEuiccData} ->
		    EumCertificatePresent = maps:is_key(eumCertificate, IpaEuiccData),
		    EuiccCertificatePresent = maps:is_key(euiccCertificate, IpaEuiccData),
		    if
			EumCertificatePresent and EuiccCertificatePresent ->
			    EumCertificate = maps:get(eumCertificate, IpaEuiccData),
			    EuiccCertificate = maps:get(euiccCertificate, IpaEuiccData),
			    store_euicc_pubkey(EumCertificate, EuiccCertificate, EidValue);
			true ->
			    % We need the eumCertificate and the euiccCertificate, if one of the two is missing, we can
			    % not proceed.
			    ok
		    end;
		_ ->
		    % The message format does not contain any public key information
		    ok
	    end;
	_ ->
	    % There is already a public key stored for this eUICC
	    ok
    end.
